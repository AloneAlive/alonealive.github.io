<!DOCTYPE html>

<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <!--
        hexo-theme-suka © SukkaW
        GitHub: https://github.com/SukkaW/hexo-theme-suka
    -->

    <!-- ### Resource Hint ### -->

    <!-- ## DNS Prefetch ## -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

<!-- busuanzi -->

    <link rel="dns-prefetch" href="//busuanzi.ibruce.info">


<!-- comment -->






    <link rel="dns-prefetch" href="//cdn1.lncld.net">


<!-- analytics -->







    <!-- ## Preload ## -->
    
    <!-- Busuanzi -->
    
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" as="script">







    <!-- ### Meta & Title & Info ### -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <meta name="renderer" content="webkit">

    <!-- Title -->
    <title>Android HWUI绘制流程 | sunwengang blog</title>

    <!-- Favicons -->
    <link rel="icon" type="image&#x2F;ico" href="/img/favicon.ico">

    <!-- ### Import File ### -->
    <link rel="stylesheet" href="/lib/spectre/spectre.min.css"><style>
    body {
        background-color: #f8f9fa;
    }

    a, a:visited {
        color: #8E354A;
    }

    a:active, a:focus, a:hover {
        color: #8E354A;
        opacity: .75;
    }

    #post-content a,
    #post-content a:hover,
    #post-content a:focus,
    #post-content a:visited {
        color: #005eb9;
        opacity: 1;
    }

    

    .post-entry .card-body a {
        color: #8E354A;
    }

    .avatar {
        background: #444;
    }

    .navbar-link,
    .navbar-link:visited,
    .timeline .timeline-item .timeline-icon.icon-lg {
        color: #8E354A;
    }

    .navbar-link:hover {
        color: #8E354A;
        opacity: .8;
    }

    #search-input .btn,
    #disqus_click_btn,
    #disqus-switch-to-direct,
    #disqus-loadmore-button {
        background: #727e96;
        border-color: #727e96;
        color: #fff;
    }

    #post-toc a.post-toc-link,
    #post-toc a.post-toc-link:visited,
    .share-menu.menu .menu-item>a {
        color: #727e96;
    }

    .share-menu.menu .menu-item>a:hover,
    .share-menu.menu .menu-item>a:focus,
    .share-menu.menu .menu-item>a:visited {
        color: #50596c;
        background: #f8f9fa;
        opacity: .85;
    }
</style><link rel="stylesheet" href="/css/style.min.css">








    <!-- Prettify Theme -->
    
    <link rel="preload" href="/css/highlight/arduino-light.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/css/highlight/arduino-light.min.css"></noscript>





<script>
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent("onload",function(){e.poly(),t.clearInterval(a)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this);
</script>

    <!-- ### Site Verification ### -->
    


    <link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="sunwengang blog"><meta name="msapplication-starturl" content="http://wizzie.top"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="sunwengang blog"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- ### The Open Graph & Twitter Card Protocol ### -->
    <meta property="og:title" content="Android HWUI绘制流程 | sunwengang blog"><meta property="og:site_name" content="sunwengang blog"><meta property="og:type" content="article"><meta property="og:url" content="http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/"><meta property="og:locale" content="zh-CN"><meta name="description" content="Android中绘图的API有很多，比如2D的绘图skia；3D的绘图OpenGLES，Vulkan等。Android在后来完善3D API支持的同时，也在更新View Widget渲染机制，提出了硬件加速机制。 - sunwengang - sunwengang blog"><meta name="keywords" content="graphivs"><meta property="article:published_time" content="2020-07-05T15:52:00.000Z"><meta property="article:modified_time" content="2020-07-05T13:26:47.101Z"><meta property="og:updated_time" content="2020-07-05T13:26:47.101Z"><meta property="article:author" content="sunwengang"><meta property="article:tag" content="graphivs"><meta name="twitter:card" content="summary">

    

    <!-- ### Canonical link ### -->
    <link rel="canonical" href="http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/">

    <meta name="generator" content="Hexo 4.2.0">

    <!-- ### Analytics ### -->
    







    <!-- ### Structured Data ### -->
    



<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/",
    "@type": "BlogPosting",
    "logo": "http://wizzie.top/img/favicon.ico",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/"
    },
    "headline": "Android HWUI绘制流程 | sunwengang blog",
    
    "image": {
        "@type": "ImageObject",
        "url": "http://wizzie.top/img/favicon.ico"
    },
    
    "datePublished": "2020-07-05T15:52:00.000Z",
    "dateModified": "2020-07-05T13:26:47.101Z",
    "author": {
        "@type": "Person",
        "name": "sunwengang",
        "image": {
            "@type": "ImageObject",
            "url": "http://wizzie.top/img/avatar.jpg"
        },
        "description": "developer | android display/graphics"
    },
    "publisher": {
        "@type": "Organization",
        "name": "sunwengang blog",
        "logo": {
            "@type": "ImageObject",
            "url": "http://wizzie.top/img/favicon.ico"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "http://wizzie.top/search?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "graphivs",
    "description": "Android中绘图的API有很多，比如2D的绘图skia；3D的绘图OpenGLES，Vulkan等。Android在后来完善3D API支持的同时，也在更新View Widget渲染机制，提出了硬件加速机制。 - sunwengang - sunwengang blog"
}
</script>



    <!-- ### Custom Head ### -->
    
</head>

    <body>
            

            <!-- ### Main content ### -->
            <!-- ## Header ##-->
<header>
    <h1 class="header-title text-center"><a href="/">sunwengang blog</a></h1>

    <p class="text-center header-slogan">
        
            
                developer | android display/graphics
            
        
    </p>

    <nav class="navbar-section text-center">
    
        <a href="/" class="navbar-link">首页</a>
    
    
        <a href="/archives/" class="navbar-link">归档</a>
    
    
        <a href="/search" class="navbar-link">搜索</a>
    
    
        <a href="/tags" class="navbar-link">标签</a>
    
        <a href="/html/nav.html" class="navbar-link">导航</a>
    
        <a href="/links" class="navbar-link">友链</a>
    
    
        <div class="dropdown dropdown-right">
    <a class="navbar-link dropdown-toggle" tabindex="0">分享</a>
    <ul class="menu share-menu">

        <!-- Share Weibo -->
        
        <li class="menu-item">
            <a href="http://service.weibo.com/share/share.php?appkey=&title=sunwengang blog&url=http://wizzie.top&pic=http://wizzie.top/img/favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
        </li>
        

        <!-- Share Twitter -->
        
        <li class="menu-item">
            <a href="https://twitter.com/intent/tweet?text=sunwengang blog&url=http://wizzie.top&via=sunwengang" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
        </li>
        

        <!-- Share Facebook -->
        
        <li class="menu-item">
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://wizzie.top" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
        </li>
        

        <!-- Share Google+ -->
        
        <li class="menu-item">
            <a href="https://plus.google.com/share?url=http://wizzie.top" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
        </li>
        

        <!-- Share LinkedIn -->
        
        <li class="menu-item">
            <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://wizzie.top&title=Android HWUI绘制流程" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
        </li>
        

        <!-- Share QQ -->
        
        <li class="menu-item">
            <a href="http://connect.qq.com/widget/shareqq/index.html?site=sunwengang blog&title=Android HWUI绘制流程&summary=&pics=http://wizzie.top/img/favicon.ico&url=http://wizzie.top" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
        </li>
        

        <!-- Share Telegram -->
        
        <li class="menu-item">
            <a href="https://t.me/share/url?url=http://wizzie.top&text=Android HWUI绘制流程" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
        </li>
        

        <!-- QRCode -->
        
        <li class="menu-item">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJQAAACUCAAAAABQV18IAAAB3ElEQVR42u3awa6DMAxEUf7/p9tVJYTimTHqgpjLBtQWcp6UF2M7x+eBxwEKFChQC9QhjvP3v+vzfdfr1fl6XY0DahZqOekKiBq4giTjgJqHWk1wNdAKo/6oaBxQr0BVZxtcBRLUu1FqoVzdlwRrUO9AJRNVBd/qN51xQM1BucThX+e/ZjOgHotKA6sbpLo3DeCg5qBcMSJJPKv7ykWyeh6oMagkSagKF0mwdt+Bmo2qJqsawAXetDACagbqTjG2G3zTYgmoGag0gKpGUlIci/CgxqBcwcIVOlziUeHlRAe1PcolDi4pSLD2nwTUGFR3QFXIT5LYKrCDmoFyhfy0Qa0WRvUcUPNQbtNDmrSql0JX7AA1C+USg6RAmyQdKsEFNQvVaUJ3ivUumY2TUVDboVwxPimEuaZ4XPwANQLVeaFLmtXJ5vnyM1AjUGkhNdnsrBpGSUEE1BxU2uxxE74byKPEAdR2qHQjn0oq3AIsNweCGodKGz6dgWXzWr0EghqBSie4Kqx1Nm/J54Aag0o337jBOkG7XTQDtR0qKbJ2i7TpwgvqXahOonAnmQAFym3w6vzu9uIJagtU0khUCeVdtJzooLZFpU0f13hMJ3Z7oyCorVBPOkCBAgXqdHwBKQMPvuXfDLgAAAAASUVORK5CYII=" alr="QRCode">
        </li>
        

    </ul>
</div>
    
    
</nav>
</header>

            
    <!-- ## Post ## -->
    <div class="post-container">
    <div id="post-card" class="card">
        
        <div class="card-item-container">
            <div class="card-inner-cell">
                <!-- # Post Header Info # -->
                <div class="card-header">
                    
    <h1 class="card-title h3 mb-2">Android HWUI绘制流程</h1>




<div class="post-header-info">
    <p class="post-header-info-left text-gray">
        <img class="author-thumb lazyload" data-src="/img/avatar.jpg" src="/img/suka-lazyload.gif" alt="sunwengang's Avatar">
        <span>2020-07-05</span>
        
            <span class="suka-devide-dot"></span>
            <a class="category-link" href="/categories/android/">android</a>
        
        
            <!-- Busuanzi Post Views -->
<span id="busuanzi_container_page_pv" hidden>
    <span class="suka-devide-dot"></span>
    <span></span>
    <span id="busuanzi_value_page_pv"></span>
    <span>Views</span>
</span>
        
        
    </p>
    <div class="post-header-info-right">
        
            <div class="dropdown dropdown-right">
<a class="dropdown-toggle" tabindex="0">分享本文</a>
<ul class="menu share-menu">
    <!-- Share Weibo -->
    
    <li class="menu-item">
        <a href="http://service.weibo.com/share/share.php?appkey=&title=Android HWUI绘制流程&url=http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/&pic=http://wizzie.top/img/favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
    </li>
    

    <!-- Share Twitter -->
    
    <li class="menu-item">
        <a href="https://twitter.com/intent/tweet?text=Android HWUI绘制流程&url=http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/&via=sunwengang" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
    </li>
    

    <!-- Share Facebook -->
    
    <li class="menu-item">
        <a href="https://www.facebook.com/sharer/sharer.php?u=http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
    </li>
    

    <!-- Share Google+ -->
    
    <li class="menu-item">
        <a href="https://plus.google.com/share?url=http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
    </li>
    

    <!-- Share LinkedIn -->
    
    <li class="menu-item">
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/&title=sunwengang blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
    </li>
    

    <!-- Share QQ -->
    
    <li class="menu-item">
        <a href="http://connect.qq.com/widget/shareqq/index.html?site=sunwengang blog&title=sunwengang blog&summary=&pics=http://wizzie.top/img/favicon.ico&url=http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
    </li>
    

    <!-- Share Telegram -->
    
    <li class="menu-item">
        <a href="https://t.me/share/url?url=http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/&text=sunwengang blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
    </li>
    

    <!-- QRCode -->
    
    <li class="menu-item">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJQAAACUCAAAAABQV18IAAAB3ElEQVR42u3awa6DMAxEUf7/p9tVJYTimTHqgpjLBtQWcp6UF2M7x+eBxwEKFChQC9QhjvP3v+vzfdfr1fl6XY0DahZqOekKiBq4giTjgJqHWk1wNdAKo/6oaBxQr0BVZxtcBRLUu1FqoVzdlwRrUO9AJRNVBd/qN51xQM1BucThX+e/ZjOgHotKA6sbpLo3DeCg5qBcMSJJPKv7ykWyeh6oMagkSagKF0mwdt+Bmo2qJqsawAXetDACagbqTjG2G3zTYgmoGag0gKpGUlIci/CgxqBcwcIVOlziUeHlRAe1PcolDi4pSLD2nwTUGFR3QFXIT5LYKrCDmoFyhfy0Qa0WRvUcUPNQbtNDmrSql0JX7AA1C+USg6RAmyQdKsEFNQvVaUJ3ivUumY2TUVDboVwxPimEuaZ4XPwANQLVeaFLmtXJ5vnyM1AjUGkhNdnsrBpGSUEE1BxU2uxxE74byKPEAdR2qHQjn0oq3AIsNweCGodKGz6dgWXzWr0EghqBSie4Kqx1Nm/J54Aag0o337jBOkG7XTQDtR0qKbJ2i7TpwgvqXahOonAnmQAFym3w6vzu9uIJagtU0khUCeVdtJzooLZFpU0f13hMJ3Z7oyCorVBPOkCBAgXqdHwBKQMPvuXfDLgAAAAASUVORK5CYII=" alt="QRCode">
    </li>
    

</ul>
</div>
        
    </div>
</div>
                </div>
                <div class="card-body">
                    
                        
                        
                            <div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#GPU渲染（硬件加速）介绍"><span class="post-toc-number">1.</span> <span class="post-toc-text">GPU渲染（硬件加速）介绍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Android-5-0-之后的渲染框架"><span class="post-toc-number">2.</span> <span class="post-toc-text">Android 5.0 之后的渲染框架</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Android原生硬件绘制案例"><span class="post-toc-number">3.</span> <span class="post-toc-text">Android原生硬件绘制案例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Java层相关流程（frameworks-base的View模块和graphics模块）"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">Java层相关流程（frameworks&#x2F;base的View模块和graphics模块）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Native层Canvas创建（JNI和HWUI模块）"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">Native层Canvas创建（JNI和HWUI模块）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Natvie层Draw绘制操纵"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">Natvie层Draw绘制操纵</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建RenderNode"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">创建RenderNode</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HwuiContext和HwuiRenderer"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">HwuiContext和HwuiRenderer</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Java层"><span class="post-toc-number">3.5.1.</span> <span class="post-toc-text">Java层</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#JNI层"><span class="post-toc-number">3.5.2.</span> <span class="post-toc-text">JNI层</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#native层：调用RenderProxy-cpp构造函数"><span class="post-toc-number">3.5.3.</span> <span class="post-toc-text">***native层：调用RenderProxy.cpp构造函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CanvasContext渲染上下文"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">CanvasContext渲染上下文</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#RenderThread渲染线程"><span class="post-toc-number">3.6.1.</span> <span class="post-toc-text">RenderThread渲染线程</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#DrawFrameTask"><span class="post-toc-number">3.6.2.</span> <span class="post-toc-text">DrawFrameTask</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#绘制准备，同步帧"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">绘制准备，同步帧</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#prepareTree"><span class="post-toc-number">3.7.1.</span> <span class="post-toc-text">prepareTree</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#draw绘制"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">draw绘制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#绘制完成后unlockCanvasAndPost流程"><span class="post-toc-number">3.9.</span> <span class="post-toc-text">绘制完成后unlockCanvasAndPost流程</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Activity-HWUI渲染环境初始化流程"><span class="post-toc-number">4.</span> <span class="post-toc-text">Activity HWUI渲染环境初始化流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TODO-附序列图"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">TODO 附序列图</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Java层-1"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Java层</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Native层"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">Native层</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Activity-窗口绘制流程"><span class="post-toc-number">5.</span> <span class="post-toc-text">Activity 窗口绘制流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TODO-绘制序列图"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">TODO 绘制序列图</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#关闭硬件加速"><span class="post-toc-number">6.</span> <span class="post-toc-text">关闭硬件加速</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#相关参考"><span class="post-toc-number">7.</span> <span class="post-toc-text">相关参考</span></a></li></ol></div>
                        
                    
                    <article id="post-content">
                        <blockquote>
<p>Android中绘图的API有很多，比如2D的绘图skia；3D的绘图OpenGLES，Vulkan等。Android在后来完善3D API支持的同时，也在更新View Widget渲染机制，提出了硬件加速机制。  </p>
</blockquote>
<a id="more"></a>

<blockquote>
<p><code>硬件加速</code>：<strong>作用</strong>：是将2D的绘图操纵转换为对应的3D绘图操纵。需要显示的时候，再用OpenGLES通过GPU渲染。<strong>过程</strong>：界面创建时，第一次全部渲染，后续界面如果只有部分区域的widget更新，只需要重新渲染更新的widget。渲染好的绘图保存在一个显示列表<code>DisplayList</code>中，需要真正显示到界面的时候，直接显示DisplayList中的绘图。<strong>好处</strong>：一方面利用GPU去渲染，比Skia要快；另一方面，采用DisplayList，再次渲染只更新部分区域，最大程度利用上一帧的数据，提高效率。</p>
</blockquote>
<blockquote>
<p>使用Android Q AOSP源码梳理流程。</p>
</blockquote>
<h2 id="GPU渲染（硬件加速）介绍"><a href="#GPU渲染（硬件加速）介绍" class="headerlink" title="GPU渲染（硬件加速）介绍"></a>GPU渲染（硬件加速）介绍</h2><p>在Android应用程序中是通过Canvas API来绘制UI元素的。在硬件加速渲染环境中,这些Canvas API调用最终会转化为OpenGL API调用(转化过程对应用程序来说是透明的)。由于OpenGL API调用要求发生在Open GL环境中,因此在每当有新的Activity窗口启动时,系统都会为其初始化好OpenGL环境。</p>
<p>这里的渲染,主要是Android硬件加速,即GPU渲染。android上就是通过libhwui调用OpenGL api来渲染, Android P上libhwui 会调用skia,再调用GLES相关的API进行渲染。</p>
<p>GPU作为一个硬件 , 用户空间是不可以直接使用的, 它是由GPU厂商按照Open GL规范实现的驱动间接进行使用的。也就是说 , 如果一个设备支持GPU硬件加速渲染, 那么当Android应用程序调用OpenGL接口来绘制UI时 ,Android应用程序的UI就是通过硬件加速技术进行渲染的。</p>
<p><strong>名词介绍：</strong></p>
<ul>
<li>GPU:一个类似于CPU的专门用来处理Graphics的处理器, 作用用来帮助加快栅格化操作, 当然, 也有相应的缓存数据(例如缓存已经光栅化过的bitmap等)机制。</li>
<li>OpenGL ES:是手持嵌入式设备的3DAPI, 跨平台的、功能完善的2D和3D图形应用程序接口API, 有一套固定渲染管线流程</li>
<li>DisplayList:在Android把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。</li>
<li>栅格化:是将图片等矢量资源, 转化为一格格像素点的像素图, 显示到屏幕上。</li>
<li>垂直同步VSYNC:让显卡的运算和显示器刷新率一致以稳定输出的画面质量。它告知GPU在载入新帧之前,要等待屏幕绘制完成前一帧。</li>
<li>RefreshRate:屏幕一秒内刷新屏幕的次数, 由硬件决定, 例如60Hz</li>
<li>Frame Rate:GPU一秒绘制操作的帧数, 单位是fps</li>
</ul>
<h2 id="Android-5-0-之后的渲染框架"><a href="#Android-5-0-之后的渲染框架" class="headerlink" title="Android 5.0 之后的渲染框架"></a>Android 5.0 之后的渲染框架</h2><p>在Android应用程序窗口中, 每一个View都抽象为一个Render Node, 而且如果一个View设置有Background, 这个background 也被抽象为一个Render Node 。</p>
<p>这是由于在OpenGLRenderer库中, 并没有View的概念, 所有的一切可绘制的元素都抽象为一个Render Node。</p>
<p>每一个Render Node都关联有一个<code>DisplayList Renderer</code>, Display List是一个绘制命令缓冲区。当View的成员函数onDraw被调用时, 我们调用通过参数传递进来的Canvas的<code>drawXXX</code>成员函数绘制图形时, 我们实际上只是将对应的绘制命令以及参数保存在一个Display List中。接下来再通过DisplayList Renderer执行这个Display List的命令, 这个过程称为Display List Replay。</p>
<p>Android应用程序窗口的View是通过树形结构来组织的。这些View不管是通过硬件加速渲染还是软件渲染, 或者是一个特殊的TextureView,在它们的成员函数onDraw被调用期间, 它们都是将自己的UI绘制在ParentView的DisplayList中。</p>
<p>其中, 最顶层的Parent View是一个Root View, 它关联的RootNode称为<code>Root Render Node</code>。也就是说, 最终Root Render Node的DisplayList将会包含一个窗口的所有绘制命令。</p>
<p>在绘制窗口的下一帧时, RootRender Node的Display List都会通过一个OpenGL Renderer真正地通过Open GL命令绘制在一个<code>Graphic Buffer</code>中。</p>
<p>最后这个 Graphic Buffer 被交给 SurfaceFlinger 服务进行合成和显示。</p>
<h2 id="Android原生硬件绘制案例"><a href="#Android原生硬件绘制案例" class="headerlink" title="Android原生硬件绘制案例"></a>Android原生硬件绘制案例</h2><p>Android原生的硬件绘制案例，在<code>frameworks/base/tests/HwAccelerationTest/src/com/android/test/hwui/HardwareCanvasSurfaceViewActivity.java</code>：</p>
<figure class="highlight java"><figcaption><span>HardwareCanvasSurfaceViewActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderingThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SurfaceHolder mSurface;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mRunning = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mWidth, mHeight;</span><br><span class="line">        <span class="comment">//应用拿到一个Surface</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RenderingThread</span><span class="params">(SurfaceHolder surface)</span> </span>&#123;</span><br><span class="line">            mSurface = surface;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            mWidth = width;</span><br><span class="line">            mHeight = height;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> x = <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">float</span> y = <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">float</span> speedX = <span class="number">5.0f</span>;</span><br><span class="line">            <span class="keyword">float</span> speedY = <span class="number">3.0f</span>;</span><br><span class="line"></span><br><span class="line">            Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">            paint.setColor(<span class="number">0xff00ff00</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (mRunning &amp;&amp; !Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">//先调用Surface的lockHardwareCanvas函数</span></span><br><span class="line">                <span class="keyword">final</span> Canvas canvas = mSurface.lockHardwareCanvas();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//绘制</span></span><br><span class="line">                    canvas.drawColor(<span class="number">0x00000000</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">                    canvas.drawRect(x, y, x + <span class="number">20.0f</span>, y + <span class="number">20.0f</span>, paint);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//绘制完成后</span></span><br><span class="line">                    mSurface.unlockCanvasAndPost(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x + <span class="number">20.0f</span> + speedX &gt;= mWidth || x + speedX &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    speedX = -speedX;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (y + <span class="number">20.0f</span> + speedY &gt;= mHeight || y + speedY &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    speedY = -speedY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                x += speedX;</span><br><span class="line">                y += speedY;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//每个15s循环一次</span></span><br><span class="line">                    Thread.sleep(<span class="number">15</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// Interrupted</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stopRendering</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            interrupt();</span><br><span class="line">            mRunning = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java层相关流程（frameworks-base的View模块和graphics模块）"><a href="#Java层相关流程（frameworks-base的View模块和graphics模块）" class="headerlink" title="Java层相关流程（frameworks/base的View模块和graphics模块）"></a>Java层相关流程（frameworks/base的View模块和graphics模块）</h3><ol>
<li>首先调用关键函数<code>lockHardwareCanvas</code>，在<code>frameworks/base/core/java/android/view/SurfaceView.java</code>：</li>
</ol>
<figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/SurfaceView.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Surface <span class="title">getSurface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockHardwareCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> internalLockCanvas(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Canvas <span class="title">internalLockCanvas</span><span class="params">(Rect dirty, <span class="keyword">boolean</span> hardware)</span> </span>&#123;</span><br><span class="line">        mSurfaceLock.lock();</span><br><span class="line">        Canvas c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mDrawingStopped &amp;&amp; mSurfaceControl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hardware) &#123;</span><br><span class="line">                    <span class="comment">//hardware传递的是true，执行lockHardwareCanvas</span></span><br><span class="line">                    c = mSurface.lockHardwareCanvas();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = mSurface.lockCanvas(dirty);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(LOG_TAG, <span class="string">"Exception locking surface"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLastLockTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mLastLockTime = now;</span><br><span class="line">        mSurfaceLock.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>然后就调用Surface.java的lockHardwareCanvas函数，此处封装了一个<code>HwuiContext</code>对象，构造函数如下：</p>
<figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Canvas <span class="title">lockHardwareCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Log.d(TAG, <span class="string">"lockHardwareCanvas"</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">          checkNotReleasedLocked();</span><br><span class="line">          <span class="keyword">if</span> (mHwuiContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//创建HwuiContext</span></span><br><span class="line">              mHwuiContext = <span class="keyword">new</span> HwuiContext(<span class="keyword">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//调用他的lockCanvas函数</span></span><br><span class="line">          <span class="keyword">return</span> mHwuiContext.lockCanvas(</span><br><span class="line">                  nativeGetWidth(mNativeObject),</span><br><span class="line">                  nativeGetHeight(mNativeObject));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从上面调用到</span></span><br><span class="line">  <span class="function">Canvas <span class="title">lockCanvas</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mCanvas != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Surface was already locked!"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//调用RenderNode的beginRecording函数</span></span><br><span class="line">          mCanvas = mRenderNode.beginRecording(width, height);</span><br><span class="line">          <span class="keyword">return</span> mCanvas;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HwuiContext</span> </span>&#123;</span><br><span class="line">      <span class="comment">//创建RenderNode和HwuiRender</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> RenderNode mRenderNode;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">long</span> mHwuiRenderer;</span><br><span class="line">      <span class="keyword">private</span> RecordingCanvas mCanvas;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mIsWideColorGamut;</span><br><span class="line">      <span class="comment">//构造函数</span></span><br><span class="line">      HwuiContext(<span class="keyword">boolean</span> isWideColorGamut) &#123;</span><br><span class="line">          <span class="comment">//创建一个RenderNode</span></span><br><span class="line">          mRenderNode = RenderNode.create(<span class="string">"HwuiCanvas"</span>, <span class="keyword">null</span>);</span><br><span class="line">          mRenderNode.setClipToBounds(<span class="keyword">false</span>);</span><br><span class="line">          mRenderNode.setForceDarkAllowed(<span class="keyword">false</span>);</span><br><span class="line">          mIsWideColorGamut = isWideColorGamut;</span><br><span class="line">          <span class="comment">//创建一个native的HwuiRender对象</span></span><br><span class="line">          mHwuiRenderer = nHwuiCreate(mRenderNode.mNativeRenderNode, mNativeObject,</span><br><span class="line">                  isWideColorGamut);</span><br><span class="line">      &#125;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在Surface.java中通过lockCanvas调用RenderNode对象的<code>beginRecording</code>函数。</li>
</ol>
<figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RenderNode.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">RecordingCanvas <span class="title">beginRecording</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (mCurrentRecordingCanvas != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                 <span class="string">"Recording currently in progress - missing #endRecording() call?"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     mCurrentRecordingCanvas = RecordingCanvas.obtain(<span class="keyword">this</span>, width, height);</span><br><span class="line">     <span class="keyword">return</span> mCurrentRecordingCanvas;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>接着调用RecordingCanvas的obtain函数：</p>
<p><strong>类的继承关系：</strong> RecordingCanvas类继承DisplayListCanvas，而DisplayListCanvas继承BaseRecordingCanvas，<br>BaseRecordingCanvas继承Canvas（继承BaseCanvas）。</p>
<figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RecordingCanvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordingCanvas</span> <span class="keyword">extends</span> <span class="title">DisplayListCanvas</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RecordingCanvas</span><span class="params">(@NonNull RenderNode node, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nCreateDisplayListCanvas(node.mNativeRenderNode, width, height));</span><br><span class="line">        mDensity = <span class="number">0</span>; <span class="comment">// disable bitmap density scaling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RecordingCanvas <span class="title">obtain</span><span class="params">(@NonNull RenderNode node, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"node cannot be null"</span>);</span><br><span class="line">        RecordingCanvas canvas = sPool.acquire();</span><br><span class="line">        <span class="keyword">if</span> (canvas == <span class="keyword">null</span>) &#123;</span><br><span class="line">            canvas = <span class="keyword">new</span> RecordingCanvas(node, width, height);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个native的DisplayListCanvas对象（即显示列表的Canvas）</span></span><br><span class="line">            <span class="comment">//JNI通过mNativeCanvasWrapper（BaseCanvas.java创建）找对应的Native的Canvas</span></span><br><span class="line">            nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, node.mNativeRenderNode,</span><br><span class="line">                    width, height);</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.mNode = node;</span><br><span class="line">        canvas.mWidth = width;</span><br><span class="line">        canvas.mHeight = height;</span><br><span class="line">        <span class="keyword">return</span> canvas;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查看测试案例代码中的<code>canvas.drawColor</code>和<code>canvas.drawRect</code>函数，是调用了其父类<code>BaseCanvas</code>的对应方法。</li>
</ol>
<figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/Canvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawColor</span><span class="params">(@ColorLong <span class="keyword">long</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.drawColor(color, BlendMode.SRC_OVER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(@NonNull RectF rect, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.drawRect(rect, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类<code>BaseCanvas.java</code>：</p>
<figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/BaseCanvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color, @NonNull PorterDuff.Mode mode)</span> </span>&#123;</span><br><span class="line">      nDrawColor(mNativeCanvasWrapper, color, mode.nativeInt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(@NonNull Rect r, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">      throwIfHasHwBitmapInSwMode(paint);</span><br><span class="line">      drawRect(r.left, r.top, r.right, r.bottom, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Native层Canvas创建（JNI和HWUI模块）"><a href="#Native层Canvas创建（JNI和HWUI模块）" class="headerlink" title="Native层Canvas创建（JNI和HWUI模块）"></a>Native层Canvas创建（JNI和HWUI模块）</h3><p>1.在上面RecordingCanvas.java的构造函数中调用了<code>nCreateDisplayListCanvas</code>函数，对饮的JNI实现：</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_DisplayListCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kClassPathName = <span class="string">"android/graphics/RecordingCanvas"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ @FastNative ------------------</span></span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">"nCallDrawGLFunction"</span>, <span class="string">"(JJLjava/lang/Runnable;)V"</span>,</span><br><span class="line">            (<span class="keyword">void</span>*) android_view_DisplayListCanvas_callDrawGLFunction &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ @CriticalNative --------------</span></span><br><span class="line">    &#123; <span class="string">"nCreateDisplayListCanvas"</span>, <span class="string">"(JII)J"</span>,     (<span class="keyword">void</span>*) android_view_DisplayListCanvas_createDisplayListCanvas &#125;,</span><br><span class="line">    &#123; <span class="string">"nResetDisplayListCanvas"</span>,  <span class="string">"(JJII)V"</span>,    (<span class="keyword">void</span>*) android_view_DisplayListCanvas_resetDisplayListCanvas &#125;,</span><br><span class="line">    &#123; <span class="string">"nGetMaximumTextureWidth"</span>,  <span class="string">"()I"</span>,        (<span class="keyword">void</span>*) android_view_DisplayListCanvas_getMaxTextureSize &#125;,</span><br><span class="line">    &#123; <span class="string">"nGetMaximumTextureHeight"</span>, <span class="string">"()I"</span>,        (<span class="keyword">void</span>*) android_view_DisplayListCanvas_getMaxTextureSize &#125;,</span><br><span class="line">    &#123; <span class="string">"nInsertReorderBarrier"</span>,    <span class="string">"(JZ)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_insertReorderBarrier &#125;,</span><br><span class="line">    &#123; <span class="string">"nFinishRecording"</span>,         <span class="string">"(J)J"</span>,       (<span class="keyword">void</span>*) android_view_DisplayListCanvas_finishRecording &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawRenderNode"</span>,          <span class="string">"(JJ)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawRenderNode &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawTextureLayer"</span>,        <span class="string">"(JJ)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawTextureLayer &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawCircle"</span>,              <span class="string">"(JJJJJ)V"</span>,   (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawCircleProps &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawRoundRect"</span>,           <span class="string">"(JJJJJJJJ)V"</span>,(<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawRoundRectProps &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawWebViewFunctor"</span>,      <span class="string">"(JI)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawWebViewFunctor &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现，此处的renderNodePtr变量是RenderNode在native层的对象（地址）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="params">(jlong renderNodePtr,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint width, jint height)</span> </span>&#123;</span><br><span class="line">    RenderNode* renderNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用到frameworks/base/libs/hwui/hwui/Canvas.cpp，<strong>在Andorid Q中，此处只调用了<code>SkiaRecordingCanvas</code>函数。使用skia进行绘制。</strong></p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/hwui/Canvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Canvas* <span class="title">Canvas::create_recording_canvas</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, uirenderer::RenderNode* renderNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后初始化DisplayList：</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SkiaRecordingCanvas</span><span class="params">(uirenderer::RenderNode* renderNode, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    initDisplayList(renderNode, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkiaRecordingCanvas::initDisplayList</span><span class="params">(uirenderer::RenderNode* renderNode, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    mCurrentBarrier = <span class="literal">nullptr</span>;</span><br><span class="line">    SkASSERT(mDisplayList.get() == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (renderNode) &#123;</span><br><span class="line">        mDisplayList = renderNode-&gt;detachAvailableList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mDisplayList) &#123;</span><br><span class="line">        mDisplayList.reset(<span class="keyword">new</span> SkiaDisplayList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDisplayList-&gt;attachRecorder(&amp;mRecorder, SkIRect::MakeWH(width, height));</span><br><span class="line">    SkiaCanvas::reset(&amp;mRecorder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Natvie层Draw绘制操纵"><a href="#Natvie层Draw绘制操纵" class="headerlink" title="Natvie层Draw绘制操纵"></a>Natvie层Draw绘制操纵</h3><ol>
<li>Java层：上面案例中的<code>drawColor</code>和<code>drawRect</code>实际调用的是在frameworks/base/graphics/java/android/graphics/BaseCanvas.java中：</li>
</ol>
<figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/BaseCanvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color, @NonNull PorterDuff.Mode mode)</span> </span>&#123;</span><br><span class="line">      nDrawColor(mNativeCanvasWrapper, color, mode.nativeInt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(@NonNull Rect r, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">      throwIfHasHwBitmapInSwMode(paint);</span><br><span class="line">      drawRect(r.left, r.top, r.right, r.bottom, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用JNI层在：</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_graphics_Canvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gDrawMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"nDrawColor"</span>,<span class="string">"(JII)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawColor&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawColor"</span>,<span class="string">"(JJJI)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawColorLong&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawPaint"</span>,<span class="string">"(JJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawPaint&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawPoint"</span>, <span class="string">"(JFFJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawPoint&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawPoints"</span>, <span class="string">"(J[FIIJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawPoints&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawLine"</span>, <span class="string">"(JFFFFJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawLine&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawLines"</span>, <span class="string">"(J[FIIJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawLines&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawRect"</span>,<span class="string">"(JFFFFJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawRect&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> drawColor(JNIEnv* env, jobject, jlong canvasHandle, jint color, jint modeHandle) &#123;</span><br><span class="line">    SkBlendMode mode = <span class="keyword">static_cast</span>&lt;SkBlendMode&gt;(modeHandle);</span><br><span class="line">    get_canvas(canvasHandle)-&gt;drawColor(color, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(JNIEnv* env, jobject, jlong canvasHandle, jfloat left, jfloat top,</span></span></span><br><span class="line"><span class="function"><span class="params">                     jfloat right, jfloat bottom, jlong paintHandle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Paint* paint = <span class="keyword">reinterpret_cast</span>&lt;Paint*&gt;(paintHandle);</span><br><span class="line">    get_canvas(canvasHandle)-&gt;drawRect(left, top, right, bottom, *paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Native层：因为<code>class SkiaCanvas : public Canvas</code>，所以调用到SkiaCanvas类中的具体实现：</li>
</ol>
<p>调用</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/SkiaCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkiaCanvas::drawColor</span><span class="params">(<span class="keyword">int</span> color, SkBlendMode mode)</span> </span>&#123;</span><br><span class="line">    mCanvas-&gt;drawColor(color, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkiaCanvas::drawRect</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(paint.nothingToDraw())) <span class="keyword">return</span>;</span><br><span class="line">    mCanvas-&gt;drawRect(&#123;left, top, right, bottom&#125;, *filterPaint(paint));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>调用到<code>external/skia</code>图形库模块：</li>
</ol>
<blockquote>
<p>Skia是Google一个底层的图形、图像、动画、SVG、文本等多方面的图形库，是Android中图形系统的引擎。Skia作为第三方软件放在目录：<code>external/skia/</code>。</p>
</blockquote>
<p>主要包含三个库：</p>
<ul>
<li>libcorecg.so: 包含<code>/skia/src/core</code>的部分内容，比如其中的<code>Region、Rect</code>是在SurfaceFlinger里面用来计算可视区域的；</li>
<li>libsgl.so: 包含<code>/skia/src/core|effects|images|ports|utils</code>的部分和全部内容，这个实现了skia大部分的图形效果，以及图形格式的编解码；</li>
<li>libskiagl.so: 包含<code>/skia/src/gl</code>里面的内容，主要用来调用opengl实现部分效果。</li>
</ul>
<figure class="highlight cpp"><figcaption><span>external/skia/src/core/SkCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkCanvas::drawColor</span><span class="params">(SkColor c, SkBlendMode mode)</span> </span>&#123;</span><br><span class="line">    SkPaint paint;</span><br><span class="line">    paint.setColor(c);</span><br><span class="line">    paint.setBlendMode(mode);</span><br><span class="line">    <span class="keyword">this</span>-&gt;drawPaint(paint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkCanvas::drawRect</span><span class="params">(<span class="keyword">const</span> SkRect&amp; r, <span class="keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    TRACE_EVENT0(<span class="string">"skia"</span>, TRACE_FUNC);</span><br><span class="line">    <span class="comment">// To avoid redundant logic in our culling code and various backends, we always sort rects</span></span><br><span class="line">    <span class="comment">// before passing them along.</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;onDrawRect(r.makeSorted(), paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建RenderNode"><a href="#创建RenderNode" class="headerlink" title="创建RenderNode"></a>创建RenderNode</h3><blockquote>
<p>RenderNode用以绘图操纵的批处理，当绘制的时候，可以store和apply。java层的代码如下：其实RenderNode就对应前面我们所说的ViewGroup，有一个RootView，同样也有一个RootNode。</p>
</blockquote>
<ol>
<li>在上面Surface.java调用HwuiContext构造函数的时候，会创建RenderNode对象：</li>
</ol>
<figure class="highlight java"><figcaption><span>Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HwuiContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建RenderNode和HwuiRender</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RenderNode mRenderNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mHwuiRenderer;</span><br><span class="line">    <span class="keyword">private</span> RecordingCanvas mCanvas;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mIsWideColorGamut;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    HwuiContext(<span class="keyword">boolean</span> isWideColorGamut) &#123;</span><br><span class="line">        <span class="comment">//创建一个RenderNode</span></span><br><span class="line">        mRenderNode = RenderNode.create(<span class="string">"HwuiCanvas"</span>, <span class="keyword">null</span>);</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>

<p>创建RenderNode对象：</p>
<figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RenderNode.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RenderNode <span class="title">create</span><span class="params">(String name, @Nullable AnimationHost animationHost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RenderNode(name, animationHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RenderNode</span><span class="params">(String name, AnimationHost animationHost)</span> </span>&#123;</span><br><span class="line">    mNativeRenderNode = nCreate(name);</span><br><span class="line">    NoImagePreloadHolder.sRegistry.registerNativeAllocation(<span class="keyword">this</span>, mNativeRenderNode);</span><br><span class="line">    mAnimationHost = animationHost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>JNI层：</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Regular JNI</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line">    &#123; <span class="string">"nCreate"</span>,               <span class="string">"(Ljava/lang/String;)J"</span>, (<span class="keyword">void</span>*) android_view_RenderNode_create &#125;,</span><br><span class="line">    &#123; <span class="string">"nGetNativeFinalizer"</span>,   <span class="string">"()J"</span>,    (<span class="keyword">void</span>*) android_view_RenderNode_getNativeFinalizer &#125;,</span><br><span class="line">    &#123; <span class="string">"nOutput"</span>,               <span class="string">"(J)V"</span>,    (<span class="keyword">void</span>*) android_view_RenderNode_output &#125;,</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jlong android_view_RenderNode_create(JNIEnv* env, jobject, jstring name) &#123;</span><br><span class="line">    <span class="comment">//创建一个native层的rendernode对象</span></span><br><span class="line">    RenderNode* renderNode = <span class="keyword">new</span> RenderNode();</span><br><span class="line">    renderNode-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* textArray = env-&gt;GetStringUTFChars(name, <span class="literal">NULL</span>);</span><br><span class="line">        renderNode-&gt;setName(textArray);</span><br><span class="line">        env-&gt;ReleaseStringUTFChars(name, textArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(renderNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Native层，创建好RenderNode是提供给DisplayListCanvas。</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RenderNode::RenderNode()</span><br><span class="line">        : mUniqueId(generateId())</span><br><span class="line">        , mDirtyPropertyFields(<span class="number">0</span>)</span><br><span class="line">        , mNeedsDisplayListSync(<span class="literal">false</span>)</span><br><span class="line">        , mDisplayList(<span class="literal">nullptr</span>)</span><br><span class="line">        , mStagingDisplayList(<span class="literal">nullptr</span>)</span><br><span class="line">        , mAnimatorManager(*<span class="keyword">this</span>)</span><br><span class="line">        , mParentCount(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HwuiContext和HwuiRenderer"><a href="#HwuiContext和HwuiRenderer" class="headerlink" title="HwuiContext和HwuiRenderer"></a>HwuiContext和HwuiRenderer</h3><h4 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h4><p>从上面的Surface.java中看到，nHwuiCreate创建HwuiRenderer。</p>
<figure class="highlight java"><figcaption><span>Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个native的HwuiRender对象</span></span><br><span class="line">mHwuiRenderer = nHwuiCreate(mRenderNode.mNativeRenderNode, mNativeObject,</span><br><span class="line">        isWideColorGamut);</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>

<h4 id="JNI层"><a href="#JNI层" class="headerlink" title="JNI层"></a>JNI层</h4><figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_Surface.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gSurfaceMethods[] = &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// HWUI context</span></span><br><span class="line">    &#123;<span class="string">"nHwuiCreate"</span>, <span class="string">"(JJZ)J"</span>, (<span class="keyword">void</span>*) hwui::create &#125;,</span><br><span class="line">    &#123;<span class="string">"nHwuiSetSurface"</span>, <span class="string">"(JJ)V"</span>, (<span class="keyword">void</span>*) hwui::setSurface &#125;,</span><br><span class="line">    &#123;<span class="string">"nHwuiDraw"</span>, <span class="string">"(J)V"</span>, (<span class="keyword">void</span>*) hwui::draw &#125;,</span><br><span class="line">    &#123;<span class="string">"nHwuiDestroy"</span>, <span class="string">"(J)V"</span>, (<span class="keyword">void</span>*) hwui::destroy &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=========================================具体实现</span></span><br><span class="line"><span class="keyword">namespace</span> uirenderer &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android::uirenderer::renderthread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextFactory</span> :</span> <span class="keyword">public</span> IContextFactory &#123;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">create</span><span class="params">(JNIEnv* env, jclass clazz, jlong rootNodePtr, jlong surfacePtr,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean isWideColorGamut)</span> </span>&#123;</span><br><span class="line">    RenderNode* rootNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(rootNodePtr);</span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface*&gt;(surfacePtr))</span></span>;</span><br><span class="line">    ContextFactory factory;</span><br><span class="line">    <span class="comment">//创建一个RenderProxy对象，并作为返回对象</span></span><br><span class="line">    RenderProxy* proxy = <span class="keyword">new</span> RenderProxy(<span class="literal">false</span>, rootNode, &amp;factory);</span><br><span class="line">    proxy-&gt;loadSystemProperties();</span><br><span class="line">    <span class="keyword">if</span> (isWideColorGamut) &#123;</span><br><span class="line">        proxy-&gt;setWideGamut(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    proxy-&gt;setSwapBehavior(SwapBehavior::kSwap_discardBuffer);</span><br><span class="line">    proxy-&gt;setSurface(surface);</span><br><span class="line">    <span class="comment">// Shadows can't be used via this interface, so just set the light source</span></span><br><span class="line">    <span class="comment">// to all 0s.</span></span><br><span class="line">    proxy-&gt;setLightAlpha(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    proxy-&gt;setLightGeometry((Vector3)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (jlong) proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="native层：调用RenderProxy-cpp构造函数"><a href="#native层：调用RenderProxy-cpp构造函数" class="headerlink" title="***native层：调用RenderProxy.cpp构造函数"></a>***native层：调用RenderProxy.cpp构造函数</h4><p>该构造函数的几个重要成员变量：</p>
<ul>
<li>RenderProxy是一个代理者，严格的单线程。所有的方法都必须在自己的线程中调用。<code>MainThread通过这个代理对象想Task Queue发送drawFrame命令</code>；</li>
<li>RenderThread（即构造函数中的mRenderThread）：渲染线程，是一个单例，也就是说，一个进程中只有一个，所有的绘制操纵都必须在这个线程中完成。应用端很多操纵，都以RenderTask的形式post到RenderThread线程中完成。（在Android 5.0之后独立出来的应用程序的OpenGL线程）</li>
<li>CanvasContext（即构造函数中的mContext）：上下文，由于OpenGL是单线程的，所以，我们给到GPU的绘图命令都封装在各自的上下文中。这个和上层的HwuiRenderer是对应的。（将窗口绑定到Open GL渲染上下文中，从而使后面的渲染操作都是针对被绑定窗口的）</li>
<li>DrawFrameTask（即构造函数中的mDrawFrameTask）：一个用来执行渲染任务的task，MainThread通过他向RenderThread线程发送渲染下一帧的命令。（比较特殊的一个RenderTask，可重复使用的绘制Task。）</li>
</ul>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="keyword">namespace</span> uirenderer &#123;</span><br><span class="line"><span class="keyword">namespace</span> renderthread &#123;</span><br><span class="line"></span><br><span class="line">RenderProxy::RenderProxy(<span class="keyword">bool</span> translucent, RenderNode* rootRenderNode,</span><br><span class="line">                         IContextFactory* contextFactory)</span><br><span class="line">        : mRenderThread(RenderThread::getInstance()), mContext(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    mContext = mRenderThread.<span class="built_in">queue</span>().runSync([&amp;]() -&gt; CanvasContext* &#123;</span><br><span class="line">        <span class="keyword">return</span> CanvasContext::create(mRenderThread, translucent, rootRenderNode, contextFactory);</span><br><span class="line">    &#125;);</span><br><span class="line">    mDrawFrameTask.setContext(&amp;mRenderThread, mContext, rootRenderNode);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="CanvasContext渲染上下文"><a href="#CanvasContext渲染上下文" class="headerlink" title="CanvasContext渲染上下文"></a>CanvasContext渲染上下文</h3><p>该函数中会选择渲染绘制方式（渲染管线）。在Android Q中取消了OpenGL渲染。</p>
<ul>
<li>Android P之前：<code>enum class RenderPipelineType { OpenGL = 0, SkiaGL, SkiaVulkan, NotInitialized = 128 };</code></li>
<li>Android Q：<code>enum class RenderPipelineType { SkiaGL, SkiaVulkan, NotInitialized = 128 };</code></li>
</ul>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CanvasContext* <span class="title">CanvasContext::create</span><span class="params">(RenderThread&amp; thread, <span class="keyword">bool</span> translucent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     RenderNode* rootRenderNode, IContextFactory* contextFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取渲染方式getRenderPipelineType</span></span><br><span class="line">    <span class="keyword">auto</span> renderType = Properties::getRenderPipelineType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (renderType) &#123;</span><br><span class="line">        <span class="keyword">case</span> RenderPipelineType::SkiaGL:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,</span><br><span class="line">                                     <span class="built_in">std</span>::make_unique&lt;skiapipeline::SkiaOpenGLPipeline&gt;(thread));</span><br><span class="line">        <span class="keyword">case</span> RenderPipelineType::SkiaVulkan:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,</span><br><span class="line">                                     <span class="built_in">std</span>::make_unique&lt;skiapipeline::SkiaVulkanPipeline&gt;(thread));</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"canvas context type %d not supported"</span>, (<span class="keyword">int32_t</span>)renderType);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RenderPipelineType <span class="title">Properties::getRenderPipelineType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sRenderPipelineType = peekRenderPipelineType();</span><br><span class="line">    <span class="keyword">return</span> sRenderPipelineType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RenderPipelineType <span class="title">Properties::peekRenderPipelineType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If sRenderPipelineType has been locked, just return the locked type immediately.</span></span><br><span class="line">    <span class="keyword">if</span> (sRenderPipelineType != RenderPipelineType::NotInitialized) &#123;</span><br><span class="line">        <span class="keyword">return</span> sRenderPipelineType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> useVulkan = use_vulkan().value_or(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="comment">//PROPERTY_RENDERER "debug.hwui.renderer"</span></span><br><span class="line">    <span class="comment">//enum class RenderPipelineType &#123; SkiaGL, SkiaVulkan, NotInitialized = 128 &#125;;</span></span><br><span class="line">    property_get(PROPERTY_RENDERER, prop, useVulkan ? <span class="string">"skiavk"</span> : <span class="string">"skiagl"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(prop, <span class="string">"skiavk"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> RenderPipelineType::SkiaVulkan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RenderPipelineType::SkiaGL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>mRenderPipeline有几种类型，创建CanvasContext时（<code>create函数</code>），会根据pipeline的类型，创建对应的Pipeline。（即调用<code>getRenderPipelineType函数</code>）</p>
</blockquote>
<ul>
<li>渲染类型：<code>enum class RenderPipelineType { SkiaGL, SkiaVulkan, NotInitialized = 128 };</code></li>
</ul>
<hr>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">CanvasContext::CanvasContext(RenderThread&amp; thread, <span class="keyword">bool</span> translucent, RenderNode* rootRenderNode,</span><br><span class="line">                             IContextFactory* contextFactory,</span><br><span class="line">                             <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;IRenderPipeline&gt; renderPipeline)</span><br><span class="line">        : mRenderThread(thread)</span><br><span class="line">        , mGenerationID(<span class="number">0</span>)</span><br><span class="line">        , mOpaque(!translucent)</span><br><span class="line">        , mAnimationContext(contextFactory-&gt;createAnimationContext(mRenderThread.timeLord()))</span><br><span class="line">        , mJankTracker(&amp;thread.globalProfileData(), DeviceInfo::get()-&gt;displayInfo())</span><br><span class="line">        , mProfiler(mJankTracker.frames(), thread.timeLord().frameIntervalNanos())</span><br><span class="line">        , mContentDrawBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        , mRenderPipeline(<span class="built_in">std</span>::move(renderPipeline)) &#123;</span><br><span class="line">    rootRenderNode-&gt;makeRoot();</span><br><span class="line">    mRenderNodes.emplace_back(rootRenderNode);  <span class="comment">//是前面创建的RenderNode</span></span><br><span class="line">    mProfiler.setDensity(DeviceInfo::get()-&gt;displayInfo().density);</span><br><span class="line">    setRenderAheadDepth(Properties::defaultRenderAhead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面调用nHwuiCreate的JNI层，会创建ContextFactory，然后在此处的构造函数中会使用到。主要用来创建AnimationContext，即<code>mAnimationContext(contextFactory-&gt;createAnimationContext(mRenderThread.timeLord()))</code></p>
<p>AnimationContext主要用来处理动画Animation。</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_Surface.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextFactory</span> :</span> <span class="keyword">public</span> IContextFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AnimationContext* <span class="title">createAnimationContext</span><span class="params">(renderthread::TimeLord&amp; clock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnimationContext(clock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>CanvasContext实现了IFrameCallback接口，所以，CanvasContext能接收编舞者Choreographer的callback，处理实时动画。<code>class CanvasContext : public IFrameCallback {...}</code></li>
</ul>
<h4 id="RenderThread渲染线程"><a href="#RenderThread渲染线程" class="headerlink" title="RenderThread渲染线程"></a>RenderThread渲染线程</h4><blockquote>
<p><strong>RenderThread渲染运行模型</strong>:空闲的时候, RenderThread睡眠在成员变量mLooper指向的一个Looper对象的成员函数pollOnceh中。当其他线程需要调度RenderThread, 会向他的任务队列添加一个任务, 然后唤醒RenderThread进行处理。RenderThread通过<code>processQueue</code>方法处理任务。</p>
</blockquote>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderThread.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承ThreadBase，而ThreadBase是继承基类Thread</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderThread</span> :</span> <span class="keyword">private</span> ThreadBase &#123;</span><br><span class="line">    <span class="comment">//组织拷贝构造函数和重载</span></span><br><span class="line">    PREVENT_COPY_AND_ASSIGN(RenderThread);</span><br></pre></td></tr></table></figure>

<ol>
<li>调用构造函数中，同时启动了渲染线程RenderThread：</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RenderThread::RenderThread()</span><br><span class="line">        : ThreadBase()</span><br><span class="line">        , mVsyncSource(<span class="literal">nullptr</span>)</span><br><span class="line">        , mVsyncRequested(<span class="literal">false</span>)</span><br><span class="line">        , mFrameCallbackTaskPending(<span class="literal">false</span>)</span><br><span class="line">        , mRenderState(<span class="literal">nullptr</span>)</span><br><span class="line">        , mEglManager(<span class="literal">nullptr</span>)</span><br><span class="line">        , mFunctorManager(WebViewFunctorManager::instance())</span><br><span class="line">        , mVkManager(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    Properties::load();</span><br><span class="line">    start(<span class="string">"RenderThread"</span>); <span class="comment">//线程启动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看父类的构造函数：</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/thread/ThreadBase.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadBase()</span><br><span class="line">        : Thread(<span class="literal">false</span>)</span><br><span class="line">        , mLooper(<span class="keyword">new</span> Looper(<span class="literal">false</span>))</span><br><span class="line">        , mQueue([<span class="keyword">this</span>]() &#123;</span><br><span class="line">             mLooper-&gt;wake();  <span class="comment">//此处调用是唤醒mLooper，线程开始工作</span></span><br><span class="line">        &#125;, mLock) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在渲染线程启动后，会调用RenderThread.cpp的threadLoop函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RenderThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_DISPLAY);</span><br><span class="line">    Looper::setForThread(mLooper);</span><br><span class="line">    <span class="keyword">if</span> (gOnStartHook) &#123;</span><br><span class="line">        gOnStartHook(<span class="string">"RenderThread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化Thread的本地变量</span></span><br><span class="line">    initThreadLocals();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//没有任务就等在此处</span></span><br><span class="line">        waitForWork();</span><br><span class="line">        processQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            drainDisplayEventQueue();</span><br><span class="line">            mFrameCallbacks.insert(mPendingRegistrationFrameCallbacks.begin(),</span><br><span class="line">                                   mPendingRegistrationFrameCallbacks.end());</span><br><span class="line">            mPendingRegistrationFrameCallbacks.clear();</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.size()) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Clean this up. This is working around an issue where a combination</span></span><br><span class="line">            <span class="comment">// of bad timing and slow drawing can result in dropping a stale vsync</span></span><br><span class="line">            <span class="comment">// on the floor (correct!) but fails to schedule to listen for the</span></span><br><span class="line">            <span class="comment">// next vsync (oops), so none of the callbacks are run.</span></span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="DrawFrameTask"><a href="#DrawFrameTask" class="headerlink" title="DrawFrameTask"></a>DrawFrameTask</h4><p>在<code>RenderProxy</code>调用构造函数时，会创建DrawFrameTask，同时调用其<code>setContext</code>函数：</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DrawFrameTask::DrawFrameTask()</span><br><span class="line">        : mRenderThread(<span class="literal">nullptr</span>)</span><br><span class="line">        , mContext(<span class="literal">nullptr</span>)</span><br><span class="line">        , mContentDrawBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        , mSyncResult(SyncResult::OK) &#123;&#125;</span><br><span class="line"></span><br><span class="line">DrawFrameTask::~DrawFrameTask() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::setContext</span><span class="params">(RenderThread* thread, CanvasContext* context,</span></span></span><br><span class="line"><span class="function"><span class="params">                               RenderNode* targetNode)</span> </span>&#123;</span><br><span class="line">    mRenderThread = thread;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mTargetNode = targetNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绘制准备，同步帧"><a href="#绘制准备，同步帧" class="headerlink" title="绘制准备，同步帧"></a>绘制准备，同步帧</h3><ol>
<li>从上面的分析看，DisplayList和RenderThread都创建好了，正常绘制的时候会调用到<code>syncAndDrawFrame</code>：</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RenderProxy::syncAndDrawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawFrameTask::drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!mContext, <span class="string">"Cannot drawFrame with no CanvasContext!"</span>);</span><br><span class="line"></span><br><span class="line">    mSyncResult = SyncResult::OK;</span><br><span class="line">    mSyncQueued = systemTime(CLOCK_MONOTONIC);</span><br><span class="line">    postAndWait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSyncResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::postAndWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mRenderThread-&gt;<span class="built_in">queue</span>().post([<span class="keyword">this</span>]() &#123; run(); &#125;); <span class="comment">//执行此处的run函数</span></span><br><span class="line">    mSignal.wait(mLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>此时，drawFrame，也就通过RenderThread，post一个WorkItem到RenderThread的队列里面，在RenderThread线程中执行的。</li>
</ol>
<p>然后RenderThread处理Queue时，执行的会是DrawFrameTask的run函数。</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_NAME(<span class="string">"DrawFrame"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> canUnblockUiThread;</span><br><span class="line">    <span class="keyword">bool</span> canDrawThisFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//info，即描述Viewtree的，也就是RenderNode tree</span></span><br><span class="line">        <span class="comment">//此处的mode是MODE_FULL，即只有primary的node是FULL，其他都是实时 **</span></span><br><span class="line">        <span class="function">TreeInfo <span class="title">info</span><span class="params">(TreeInfo::MODE_FULL, *mContext)</span></span>;</span><br><span class="line">        <span class="comment">//同步Frame帧状态</span></span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        <span class="comment">//判断是否可以绘制这一帧</span></span><br><span class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFrameCompleteCallback) &#123;</span><br><span class="line">            mContext-&gt;addFrameCompleteListener(<span class="built_in">std</span>::move(mFrameCompleteCallback));</span><br><span class="line">            mFrameCompleteCallback = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab a copy of everything we need</span></span><br><span class="line">    CanvasContext* context = mContext;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int64_t</span>)&gt; callback = <span class="built_in">std</span>::move(mFrameCallback);</span><br><span class="line">    mFrameCallback = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        <span class="comment">//**绘制</span></span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wait on fences so tasks don't overlap next frame</span></span><br><span class="line">        context-&gt;waitOnFences();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步Frame的State</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DrawFrameTask::syncFrameState</span><span class="params">(TreeInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">int64_t</span> vsync = mFrameInfo[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(FrameInfoIndex::Vsync)];</span><br><span class="line">    mRenderThread-&gt;timeLord().vsyncReceived(vsync);</span><br><span class="line">    <span class="comment">//通知GPU处理当前的Context上下文</span></span><br><span class="line">    <span class="keyword">bool</span> canDraw = mContext-&gt;makeCurrent();</span><br><span class="line">    <span class="comment">//hwui为了提高速度，对各种object都做了cache，此处unpin，就是让cache去做unpin，其他都不要了</span></span><br><span class="line">    mContext-&gt;unpinImages();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mLayers.size(); i++) &#123;</span><br><span class="line">        mLayers[i]-&gt;apply();</span><br><span class="line">    &#125;</span><br><span class="line">    mLayers.clear();</span><br><span class="line">    <span class="comment">//设置绘制的区域大小</span></span><br><span class="line">    mContext-&gt;setContentDrawBounds(mContentDrawBounds);</span><br><span class="line">    <span class="comment">//**Android View是树型结构的，这就是在绘制之前，去准备这些Tree节点的绘图操作</span></span><br><span class="line">    <span class="comment">//准备绘制一帧的数据</span></span><br><span class="line">    mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is after the prepareTree so that any pending operations</span></span><br><span class="line">    <span class="comment">// (RenderNode tree state, prefetched layers, etc...) will be flushed.</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(!mContext-&gt;hasSurface() || !canDraw)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mContext-&gt;hasSurface()) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::LostSurfaceRewardIfFound;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If we have a surface but can't draw we must be stopped</span></span><br><span class="line">            mSyncResult |= SyncResult::ContextIsStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        info.out.canDrawThisFrame = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info.out.requiresUiRedraw) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::UIRedrawRequired;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!info.out.canDrawThisFrame) &#123;</span><br><span class="line">        mSyncResult |= SyncResult::FrameDropped;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If prepareTextures is false, we ran out of texture cache space</span></span><br><span class="line">    <span class="keyword">return</span> info.prepareTextures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="prepareTree"><a href="#prepareTree" class="headerlink" title="prepareTree"></a>prepareTree</h4><ol>
<li>调用函数<strong>prepareTree</strong>：</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanvasContext::prepareTree</span><span class="params">(TreeInfo&amp; info, <span class="keyword">int64_t</span>* uiFrameInfo, <span class="keyword">int64_t</span> syncQueued,</span></span></span><br><span class="line"><span class="function"><span class="params">                                RenderNode* target)</span> </span>&#123;</span><br><span class="line">    mRenderThread.removeFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">......</span><br><span class="line">    mAnimationContext-&gt;startFrame(info.mode);</span><br><span class="line">    mRenderPipeline-&gt;onPrepareTree();</span><br><span class="line">    <span class="comment">//Context可能会有多个Node</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123;</span><br><span class="line">        <span class="comment">//即只有Primary的node是 FULL，其他都是实时</span></span><br><span class="line">        info.mode = (node.get() == target ? TreeInfo::MODE_FULL : TreeInfo::MODE_RT_ONLY);</span><br><span class="line">        <span class="comment">//此处遍历，对每个RenderNode都进行prepare</span></span><br><span class="line">        node-&gt;prepareTree(info);</span><br><span class="line">        GL_CHECKPOINT(MODERATE);</span><br><span class="line">    &#125;</span><br><span class="line">    mAnimationContext-&gt;runRemainingAnimations(info);</span><br><span class="line">    GL_CHECKPOINT(MODERATE);</span><br><span class="line"></span><br><span class="line">    freePrefetchedLayers();</span><br><span class="line">    GL_CHECKPOINT(MODERATE);</span><br><span class="line"></span><br><span class="line">    mIsDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//如果窗口已经没有Native Surface，这一帧就丢掉！！</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(!hasSurface())) &#123;</span><br><span class="line">        mCurrentFrameInfo-&gt;addFlag(FrameInfoFlags::SkippedFrame);</span><br><span class="line">        info.out.canDrawThisFrame = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">                                &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>遍历RenderNode的prepareTree方法：</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderNode::prepareTree</span><span class="params">(TreeInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!info.damageAccumulator, <span class="string">"DamageAccumulator missing"</span>);</span><br><span class="line">    <span class="function">MarkAndSweepRemoved <span class="title">observer</span><span class="params">(&amp;info)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> before = info.disableForceDark;</span><br><span class="line">    <span class="comment">//具体实现</span></span><br><span class="line">    prepareTreeImpl(observer, info, <span class="literal">false</span>);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(before != info.disableForceDark, <span class="string">"Mis-matched force dark"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>prepareTreeImpl是RenderNode真正进行Prepare的地方。</li>
</ol>
<p>damageAccumulator是从CanvasContext中传过来的，是CanvasContext的成员，damage的叠加器。主要是用来标记，屏幕的那些区域被破坏了，需要重新绘制，所有的RenderNode累加起来，就是总的。</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderNode::prepareTreeImpl</span><span class="params">(TreeObserver&amp; observer, TreeInfo&amp; info, <span class="keyword">bool</span> functorsNeedLayer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDamageGenerationId == info.damageGenerationId) &#123;</span><br><span class="line">        info.damageAccumulator-&gt;dirty(DIRTY_MIN, DIRTY_MIN, DIRTY_MAX, DIRTY_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Step 1</span></span><br><span class="line">    info.damageAccumulator-&gt;pushTransform(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.mode == TreeInfo::MODE_FULL) &#123;</span><br><span class="line">        <span class="comment">//property是对RenderNode的描述，也就是对View的描述，比如大小，位置等。</span></span><br><span class="line">        <span class="comment">//有两个状态，正在使用的syncProperties和待处理的mStagingProperties。</span></span><br><span class="line">        <span class="comment">//syncProperties时，将mStagingProperties赋值给syncProperties</span></span><br><span class="line">        pushStagingPropertiesChanges(info);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    pushLayerUpdate(info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mProperties.getAllowForceDark()) &#123;</span><br><span class="line">        info.disableForceDark--;</span><br><span class="line">    &#125;</span><br><span class="line">    info.damageAccumulator-&gt;popTransform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>调用pushTransform函数，damage累加器中，每一个元素由DirtyStack描述，分两种类型：TransformMatrix4和TransformRenderNode。采用一个双向链表mHead进行管理。</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/DamageAccumulator.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DamageAccumulator::pushCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHead-&gt;next) &#123;</span><br><span class="line">        DirtyStack* nextFrame = mAllocator.create_trivial&lt;DirtyStack&gt;();</span><br><span class="line">        nextFrame-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        nextFrame-&gt;prev = mHead;</span><br><span class="line">        mHead-&gt;next = nextFrame;</span><br><span class="line">    &#125;</span><br><span class="line">    mHead = mHead-&gt;next;</span><br><span class="line">    mHead-&gt;pendingDirty.setEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DamageAccumulator::pushTransform</span><span class="params">(<span class="keyword">const</span> RenderNode* transform)</span> </span>&#123;</span><br><span class="line">    pushCommon();</span><br><span class="line">    mHead-&gt;type = TransformRenderNode;</span><br><span class="line">    mHead-&gt;renderNode = transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时prepare完成后，绘制一帧的数据就准备好了。</p>
<hr>
<h3 id="draw绘制"><a href="#draw绘制" class="headerlink" title="draw绘制"></a>draw绘制</h3><p>绘制的过程可以围绕BufferQueue进行分析。</p>
<p>Android Q中，具体绘制是在各自的pipeline中进行的。（在<code>frameworks/base/libs/hwui/pipeline/</code>）</p>
<p>在Android P中，一般是执行的<code>frameworks/base/libs/hwui/renderthread/OpenGLPipeline.cpp</code></p>
<p>在Android Q中，可以看出Google在慢慢用Vulkan替代OpenGL。</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanvasContext::draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SkRect dirty;</span><br><span class="line">    mDamageAccumulator.finish(&amp;dirty);</span><br><span class="line">......</span><br><span class="line">    mCurrentFrameInfo-&gt;markIssueDrawCommandsStart();</span><br><span class="line">    <span class="comment">//获取frame(一帧数据信息，主要是狂傲、ufferAge、Surface等)</span></span><br><span class="line">    Frame frame = mRenderPipeline-&gt;getFrame();</span><br><span class="line">    setPresentTime();</span><br><span class="line"></span><br><span class="line">    SkRect windowDirty = computeDirtyRect(frame, &amp;dirty);</span><br><span class="line">    <span class="comment">//绘制</span></span><br><span class="line">    <span class="keyword">bool</span> drew = mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,</span><br><span class="line">                                      mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes,</span><br><span class="line">                                      &amp;(profiler()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> frameCompleteNr = mFrameCompleteCallbacks.size() ? getFrameNumber() : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    waitOnFences();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> requireSwap = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//绘制完成后调用</span></span><br><span class="line">    <span class="keyword">bool</span> didSwap =</span><br><span class="line">            mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绘制完成后unlockCanvasAndPost流程"><a href="#绘制完成后unlockCanvasAndPost流程" class="headerlink" title="绘制完成后unlockCanvasAndPost流程"></a>绘制完成后unlockCanvasAndPost流程</h3><p>回到绘制案例，此时，RenderThread，DrawFrameTask，CanvasContext等已经就绪，绘制操纵已经被添加到了DisplayList中。</p>
<ol>
<li>绘制完成，然后会在<code>frameworks/base/tests/HwAccelerationTest/src/com/android/test/hwui/HardwareCanvasSurfaceViewActivity.java</code>中调用到<code>方法unlockCanvasAndPost</code>。</li>
</ol>
<p>SurfaceHolder直接调的Surface的unlockCanvasAndPost。</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/android/view/Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            checkNotReleasedLocked();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mHwuiContext != null) &#123;</span><br><span class="line">                <span class="comment">//硬件加速执行此处</span></span><br><span class="line">                mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//软件绘制</span></span><br><span class="line">                unlockSwCanvasAndPost(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HwuiContext</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">//HwuiContext的unlockAndPost函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unlockAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (canvas != mCanvas) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"canvas object must be the same instance that "</span></span><br><span class="line">                        + <span class="string">"was previously returned by lockCanvas"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mRenderNode.endRecording();</span><br><span class="line">            mCanvas = null;</span><br><span class="line">            nHwuiDraw(mHwuiRenderer);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>上面代码看到，在lockHardwareCanvas的时候有相同流程，会调用<code>mRenderNode.beginRecording</code>。</li>
</ol>
<p>此处就对应的调用到<code>mRenderNode.endRecording();</code>，结束RenderNode。</p>
<figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RenderNode.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endRecording</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mCurrentRecordingCanvas == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                   <span class="string">"No recording in progress, forgot to call #beginRecording()?"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       RecordingCanvas canvas = mCurrentRecordingCanvas;</span><br><span class="line">       mCurrentRecordingCanvas = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//Step1 先结束Canvas的录制</span></span><br><span class="line">       <span class="keyword">long</span> displayList = canvas.finishRecording();</span><br><span class="line">       <span class="comment">//Step2 然后将录制的list给mNativeRenderNode</span></span><br><span class="line">       nSetDisplayList(mNativeRenderNode, displayList);</span><br><span class="line">       canvas.recycle();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>首先finishRecording函数通过JIN层<code>android_view_DisplayListCanvas.cpp</code>调用到Native层。</li>
</ol>
<p>返回录制好的mDisplayList。</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uirenderer::DisplayList* <span class="title">SkiaRecordingCanvas::finishRecording</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// close any existing chunks if necessary</span></span><br><span class="line">    insertReorderBarrier(<span class="literal">false</span>);</span><br><span class="line">    mRecorder.restoreToCount(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mDisplayList.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>第二步的nSetDisplayList通过JNI层<code>android_view_RenderNode.cpp</code>调用到Native层。</li>
</ol>
<p>将displayList给到RenderNode的mStagingDisplayList。</p>
<figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderNode::setStagingDisplayList</span><span class="params">(DisplayList* displayList)</span> </span>&#123;</span><br><span class="line">    mValid = (displayList != <span class="literal">nullptr</span>);</span><br><span class="line">    mNeedsDisplayListSync = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">delete</span> mStagingDisplayList;</span><br><span class="line">    mStagingDisplayList = displayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Activity-HWUI渲染环境初始化流程"><a href="#Activity-HWUI渲染环境初始化流程" class="headerlink" title="Activity HWUI渲染环境初始化流程"></a>Activity HWUI渲染环境初始化流程</h2><blockquote>
<p>主要是通过setView创建rendernode，渲染线程RenderThread，Context上下文，RenderProxy代理对象等。</p>
</blockquote>
<h3 id="TODO-附序列图"><a href="#TODO-附序列图" class="headerlink" title="TODO 附序列图"></a>TODO 附序列图</h3><p>//TODO</p>
<h3 id="Java层-1"><a href="#Java层-1" class="headerlink" title="Java层"></a>Java层</h3><ol>
<li>Activity.java开始设置view：</li>
</ol>
<figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/app/Activity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mWindow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        getWindow().setContentView(view);</span><br><span class="line">        initWindowDecorActionBar();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>PhoneWindow继承Window抽象类调用setContentView函数：</li>
</ol>
<figure class="highlight java"><figcaption><span>frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">MenuBuilder</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新对象ViewGroup</span></span><br><span class="line">        setContentView(view, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            view.setLayoutParams(params);</span><br><span class="line">            <span class="keyword">final</span> Scene newScene = <span class="keyword">new</span> Scene(mContentParent, view);</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//调用此处添加一个view到Parent View中</span></span><br><span class="line">            mContentParent.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParent.requestApplyInsets();</span><br><span class="line">        <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">        <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的<code>mContentParent.addView(view, params);</code>，mContentParent是ViewGroup类型对象。</p>
<p>ViewGroup实现接口ViewManager，而<code>interface WindowManager extends ViewManager</code>，WindowManagerImpl.java又是接口WindowManager的实现类。所以会同时调用WindowManagerImpl类的addView函数。</p>
<ol start="3">
<li>WindowManagerImpl.java调用addView函数。</li>
</ol>
<figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/WindowManagerImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>调用windowManagerGlobal的addView函数。</li>
</ol>
<figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/WindowManagerGlobal.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用ViewRootImpl的setView函数</span></span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>ViewRootImpl.java中调用流程：</li>
</ol>
<figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * We have one child</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mView = view;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// If the application owns the surface, don't enable hardware acceleration</span></span><br><span class="line">            <span class="keyword">if</span> (mSurfaceHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// While this is supposed to enable only, it can effectively disable</span></span><br><span class="line">                <span class="comment">// the acceleration too.</span></span><br><span class="line">                <span class="comment">//启动硬件加速！</span></span><br><span class="line">                enableHardwareAcceleration(attrs);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> useMTRenderer = MT_RENDERER_AVAILABLE</span><br><span class="line">                        &amp;&amp; mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (mUseMTRenderer != useMTRenderer) &#123;</span><br><span class="line">                    <span class="comment">// Shouldn't be resizing, as it's done only in window setup,</span></span><br><span class="line">                    <span class="comment">// but end just in case.</span></span><br><span class="line">                    endDragResizing();</span><br><span class="line">                    mUseMTRenderer = useMTRenderer;</span><br><span class="line">            ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableHardwareAcceleration</span><span class="params">(WindowManager.LayoutParams attrs)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mAttachInfo.mThreadedRenderer = ThreadedRenderer.create(mContext, translucent,</span><br><span class="line">                    attrs.getTitle().toString());</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在ThreadedRenderer的create函数中new了一个该对象，从而调用其构造函数。构造函数的<code>super()</code>调用基类HardwareRenderer的构造函数。</li>
</ol>
<figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/HardwareRenderer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new instance of a HardwareRenderer. The HardwareRenderer will default</span></span><br><span class="line"><span class="comment"> * to opaque with no light source configured.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//创建硬件渲染rendernode对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HardwareRenderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个窗口的Root Render Node，并用Java层的RenderNode封装起来，即adopt通过new对象返回一个java层的RenderNode对象</span></span><br><span class="line">    mRootNode = RenderNode.adopt(nCreateRootRenderNode());</span><br><span class="line">    mRootNode.setClipToBounds(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//调用到JNI层，创建一个RenderProxy（即MainThread的代理对象）</span></span><br><span class="line">    mNativeProxy = nCreateProxy(!mOpaque, mRootNode.mNativeRenderNode);</span><br><span class="line">    <span class="keyword">if</span> (mNativeProxy == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(<span class="string">"Unable to create hardware renderer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> DestroyContextRunnable(mNativeProxy));</span><br><span class="line">    ProcessInitializer.sInstance.init(mNativeProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h3><ol>
<li>从上面的nCreateRootRenderNode函数调用到JNI层的android_view_ThreadedRenderer.cpp文件中。</li>
</ol>
<p>创建一个窗口的Root Render Node。</p>
<p>之后创建RenderProxy对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createRootRenderNode</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//new对象</span></span><br><span class="line">    RootRenderNode* node = <span class="keyword">new</span> RootRenderNode(env);</span><br><span class="line">    node-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    node-&gt;setName(<span class="string">"RootRenderNode"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createProxy</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean translucent, jlong rootRenderNodePtr)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* rootRenderNode = <span class="keyword">reinterpret_cast</span>&lt;RootRenderNode*&gt;(rootRenderNodePtr);</span><br><span class="line">    <span class="function">ContextFactoryImpl <span class="title">factory</span><span class="params">(rootRenderNode)</span></span>;</span><br><span class="line">    <span class="comment">//new对象</span></span><br><span class="line">    <span class="keyword">return</span> (jlong) <span class="keyword">new</span> RenderProxy(translucent, rootRenderNode, &amp;factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>之后调用RenderProxy构造函数，就同上面Google原生绘制案例的流程分析相同<code>RenderProxy::RenderProxy(){...}</code>，负责从MainThread向RenderThread发送命令。</li>
</ol>
<p><strong>参考上面的<code>native层：调用RenderProxy.cpp构造函数</code>和<code>CanvasContext渲染上下文</code>章节</strong></p>
<hr>
<h2 id="Activity-窗口绘制流程"><a href="#Activity-窗口绘制流程" class="headerlink" title="Activity 窗口绘制流程"></a>Activity 窗口绘制流程</h2><blockquote>
<p>由ViewRootImpl的成员函数<code>performTraversals</code>发起。</p>
</blockquote>
<ol>
<li>在绘制之前，首先需要创建一个Surface，即描述一个窗口（创建Surface的流程后续单独整理）</li>
<li>一旦获得对应的Surface， 就需要将其绑定到RenderThread中。</li>
<li>Activity窗口对应的Surface是通过ViewRootImpl类的成员函数<code>relayoutWindow</code>向WindowManagerService服务请求创建和返回的，并且保存在ViewRootImpl类的成员变量mSurface中。</li>
<li>如果Surface是新创建的，将调用ViewRootImpl类的成员变量mAttachInfo指向的AttachInfo函数。对象的成员变量mHardwareRenderer描述的一个HardwareRenderer对象的成员函数<code>initialize</code>将它绑定到RenderThread中。</li>
<li>最后, 如果需要绘制当前的Activity窗口, 那会调用 iewRootImpl类的另外一个成员函数<code>performDraw</code></li>
</ol>
<h3 id="TODO-绘制序列图"><a href="#TODO-绘制序列图" class="headerlink" title="TODO 绘制序列图"></a>TODO 绘制序列图</h3><p>//TODO 序列图</p>
<hr>
<h2 id="关闭硬件加速"><a href="#关闭硬件加速" class="headerlink" title="关闭硬件加速"></a>关闭硬件加速</h2><p><strong>android关闭硬件加速的方法：</strong></p>
<ol>
<li>APK中，在AndroidManifest.xml中设置<code>android:hardwareAccelerated=&quot;false&quot;</code>，这是关闭整个app的硬件加速，慎用！</li>
<li>View有个方法支持单独的View关闭硬件加速，可以设置<code>mView.setLaterType(View.LAYER_TYPE_SOFTWARE);</code>，或者关闭某一个控件的硬件加速功能使用<code>findViewById(R.id.btn).setLayerType(View.LAYER_TYPE_SOFTWARE,null);</code></li>
</ol>
<hr>
<h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ul>
<li>Android Q AOSP： <a href="http://aosp.opersys.com/xref/android-10.0.0_r39/" target="_blank" rel="noopener">http://aosp.opersys.com/xref/android-10.0.0_r39/</a></li>
<li>Android P 图像显示系统（三）Android HWUI 绘制流程： <a href="https://www.jianshu.com/p/abfaea892611" target="_blank" rel="noopener">https://www.jianshu.com/p/abfaea892611</a></li>
</ul>

                    </article>
                    
    <blockquote class="post-license">
        <p>
            <strong>本文作者&nbsp;:&nbsp;sunwengang</strong>
            <br>
            <strong>
            
                本文使用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)</a> 协议
            </strong>
            <br>
            <strong>本文链接&nbsp;:&nbsp;</strong><a href="http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/">http://wizzie.top/2020/07/05/2020/200705_android_HWUI_Draw/</a>
        </p>
    </blockquote>



    <blockquote id="date-expire-notification" class="post-expired-notify">本文最后更新于 <span id="date-expire-num"></span> 天前，文中所描述的信息可能已发生改变</blockquote>
    <script>
    (function() {
        var dateUpdate = Date.parse("2020-07-05");
        var nowDate = new Date();
        var a = nowDate.getTime();
        var b = a - dateUpdate;
        var daysUpdateExpire = Math.floor(b/(24*3600*1000));
        if (daysUpdateExpire >= 120) {
            document.getElementById('date-expire-num').innerHTML = daysUpdateExpire;
        } else {
            document.getElementById('date-expire-notification').style.display = 'none';
        }
    })();
    </script>


<p class="post-footer-info mb-0 pt-0">本文发表于&nbsp;<time datetime="2020-07-05T15:52:00.000Z" itemprop="datePublished">2020-07-05</time>

</p>
<p class="post-footer-info mb-0 pt-2">

<span class="post-categories-list mt-2">

<a class="post-categories-list-item" href='/categories/android/'>android</a>

</span>



<span class="post-tags-list mt-2">

<a class="post-tags-list-item" href="/tags/graphivs/" rel="tag">#&nbsp;graphivs</a>

</span>


</p>

                </div>
                <div class="post-nav px-2 bg-gray">
<ul class="pagination">
    <!-- Prev Nav -->
    

    <!-- Next Nav -->
    
        <li class="page-item page-next">
            <a href="/2020/06/11/2020/200611_android_tracetxt/" rel="next">
                <div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">Android ANR traces.txt文件分析</div>
            </a>
        </li>
    
</ul>
</div>

                
                    <!-- # Comment # -->
                    
                        <div class="card-footer post-comment">
                            <div id="vcomments"></div>

<script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = '' === 'true';
    var verify = '' === 'true';
    new Valine({
        el: '#vcomments',
        notify: notify,
        verify: verify,
        appId: "vhY87VAxwU991O4b7vDREoC7-gzGzoHsz",
        appKey: "CftrDkclI3ylGGjiQeD8C2xz",
        placeholder: "Just go go",
        meta: guest_info,
        pageSize:'10',
        avatar:'identicon',
        lang:'zh-cn',
        guest_info: guest_info,
        visitor: false
    });
</script>

                        </div>
                    
                
            </div>
        </div>
    </div>
</div>

            <!-- ### Footer ### -->
            <footer class="text-center">
    <!-- footer copyright -->
    
        <p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span>
            <a class="footer-copyright-a" href="http://wizzie.top">sunwengang blog</a>
        </p>

    <!-- footer custom text -->
    <p class="footer-text mb-0">
    
    </p>
    <!-- footer develop info -->
    <p class="footer-develop mb-0">
        
    <!-- Busuanzi User Views -->
    <span id="busuanzi_container_site_uv" hidden>
        <span></span>
        <span id="busuanzi_value_site_uv"></span>
        <span>Viewers</span>
        
            <span>|</span>
        
    </span>




        
        Powered by&nbsp;<!--
         --><a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a><span class="footer-develop-divider"></span>Theme&nbsp;-&nbsp;<!--
         --><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" class="footer-develop-a" rel="external noopener">Suka</a>
    </p>
</footer>


        <!-- ### Import File ### -->
        <!-- ### Footer JS Import ### -->

<script>

    
window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 50
};

(function() {
    var copyrightNow = new Date().getFullYear();
    var copyrightContent = document.getElementById('copyright-year');
    var copyrightSince = 2019;
    if (copyrightSince === copyrightNow) {
        copyrightContent.textContent = copyrightNow;
    } else {
        copyrightContent.textContent = copyrightSince + ' - ' + copyrightNow;
    }
})();
console.log('\n %c Suka Theme (hexo-theme-suka) | © SukkaW | Verision 1.3.3 %c https://github.com/SukkaW/hexo-theme-suka \n', 'color: #fff; background: #444; padding:5px 0;', 'background: #bbb; padding:5px 0;');

</script>

<script src="/lib/vanilla-lazyload/lazyload.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


<!-- Offset -->




<!-- Comment -->

    
        
    


<!-- ### Custom Footer ### -->

    </body>

</html>